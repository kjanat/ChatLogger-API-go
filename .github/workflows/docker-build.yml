name: Build and Publish Docker Images

on:
  push:
    branches: [master, development]
    paths-ignore:
      - '**.md'
      - 'LICENSE'
      - '.github/ISSUE_TEMPLATE/**'
      - 'docs/**'
    tags: ['v*']

  # manual trigger
  workflow_dispatch:
    inputs:
      version_type:
        description: 'Which version part to bump'
        type: choice
        default: 'patch'
        options: [patch, minor, major]
      release_notes:
        description: 'Release notes/changes'
        type: string
        required: false

permissions:
  contents: read
  packages: write
  id-token: write

jobs:
  docker-build-publish:
    name: Build and Publish Docker Images
    runs-on: ubuntu-latest
    if: false
    # if: |
    #   github.ref_type == 'tag' ||
    #   github.event_name == 'workflow_dispatch' ||
    #   github.ref == 'refs/heads/master' ||
    #   github.ref == 'refs/heads/development'

    strategy:
      fail-fast: true
      matrix:
        packages:
          - server
          - worker
        goos:
          - linux
          - windows
          - darwin
        goarch:
          - amd64
          - arm64

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Go
        uses: actions/setup-go@v5
        with:
          go-version-file: 'go.mod'
          cache: true

      # Version management for non-tag builds
      - name: Extract version information
        id: version
        run: |
          if [[ "${{ github.ref }}" == refs/tags/v* ]]; then
            VERSION="${{ github.ref_name }}"
            VERSION_NO_V="${VERSION#v}"
            MAJOR="${VERSION_NO_V%%.*}"
            MINOR_PATCH="${VERSION_NO_V#*.}"
            MINOR="${MINOR_PATCH%%.*}"
          else
            # Get version from version.go file
            VERSION_STR=$(grep -oP 'Version = "\K[^"]+' internal/version/version.go)
            VERSION="v${VERSION_STR}"
            VERSION_NO_V="${VERSION#v}"
            MAJOR="${VERSION_NO_V%%.*}"
            MINOR_PATCH="${VERSION_NO_V#*.}"
            MINOR="${MINOR_PATCH%%.*}"
            
            # For non-tag builds, append short SHA
            if [[ "${{ github.event_name }}" != "workflow_dispatch" ]]; then
              SHORT_SHA=$(git rev-parse --short HEAD)
              VERSION="${VERSION}-${SHORT_SHA}"
            fi
          fi
          
          echo "VERSION=${VERSION}" >> $GITHUB_ENV
          echo "VERSION_NO_V=${VERSION_NO_V}" >> $GITHUB_ENV
          echo "MAJOR=${MAJOR}" >> $GITHUB_ENV
          echo "MINOR=${MINOR}" >> $GITHUB_ENV
          echo "BUILD_DATE=$(date -u +'%Y-%m-%dT%H:%M:%SZ')" >> $GITHUB_ENV
          echo "GIT_COMMIT=$(git rev-parse HEAD)" >> $GITHUB_ENV

      # Optional manual version bump
      - name: Manual bump & tag
        id: manual_bump
        if: github.event_name == 'workflow_dispatch'
        run: |
          cp ./scripts/version.sh ${{ runner.temp }}/version.sh
          chmod +x ${{ runner.temp }}/version.sh
          ${{ runner.temp }}/version.sh "${{ github.event.inputs.version_type }}"
          NEW=$(grep -oP 'Version = "\K[^"]+' internal/version/version.go)
          
          echo "VERSION=v${NEW}" >> $GITHUB_ENV
          echo "VERSION_NO_V=${NEW}" >> $GITHUB_ENV
          echo "MAJOR=${NEW%%.*}" >> $GITHUB_ENV
          MINOR_PATCH="${NEW#*.}"
          echo "MINOR=${MINOR_PATCH%%.*}" >> $GITHUB_ENV

          # Construct a detailed commit message
          COMMIT_MSG="chore(release): bump ${{ github.event.inputs.version_type }} version to v${NEW}"
          
          # Add release notes if provided
          if [ ! -z "${{ github.event.inputs.release_notes }}" ]; then
            COMMIT_MSG="${COMMIT_MSG}\n\n${{ github.event.inputs.release_notes }}"
          fi
          
          # Add reference to the workflow run
          COMMIT_MSG="${COMMIT_MSG}\n\nTriggered by workflow: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"
          
          git config --global user.name "${{ secrets.ACTIONS_USERNAME }}"
          git config --global user.email "${{ secrets.ACTIONS_EMAIL }}"
          git add internal/version/version.go
          git commit -m "$COMMIT_MSG"
          
          # Create a more detailed tag message
          TAG_MSG="Release v${NEW}: ${{ github.event.inputs.version_type }} version update"
          if [ ! -z "${{ github.event.inputs.release_notes }}" ]; then
            TAG_MSG="${TAG_MSG}\n\n${{ github.event.inputs.release_notes }}"
          fi
          
          git tag "v${NEW}" -m "$TAG_MSG"
          git push --follow-tags origin HEAD "v${NEW}"
          
          echo "tag_created=true" >> $GITHUB_OUTPUT
          echo "Created and pushed tag v${NEW}"

      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      # Set up cosign (optional if you want to sign images)
      - name: Set up cosign
        uses: sigstore/cosign-installer@v3.8.2

      # Build server component
      - name: Build and push ${{ matrix.packages }} image
        id: docker_build_server
        uses: docker/build-push-action@v5
        env:
          VERSION: $VERSION
          BUILD_TIME: $BUILD_DATE
          GIT_COMMIT: $GIT_COMMIT
        with:
          context: .
          file: .github/workflows/docker/Dockerfile.${{ matrix.packages }}
          push: true
          platforms: linux/amd64,linux/arm64,darwin/amd64,darwin/arm64
          build-args: |
            VERSION=$VERSION
            BUILD_TIME=$BUILD_DATE
            GIT_COMMIT=$GIT_COMMIT
          tags: |
            ghcr.io/kjanat/chatlogger-api-${{ matrix.packages }}:latest
            ghcr.io/kjanat/chatlogger-api-${{ matrix.packages }}:$VERSION
            ghcr.io/kjanat/chatlogger-api-${{ matrix.packages }}:v$MAJOR
            ghcr.io/kjanat/chatlogger-api-${{ matrix.packages }}:v$MAJOR.$MINOR
          labels: |
            org.opencontainers.image.title=chatlogger-api-go
            org.opencontainers.image.description=${{ github.event.repository.description }}
            org.opencontainers.image.url=https://github.com/users/${{ github.actor }}/packages/container/package/chatlogger-api-${{ matrix.packages }}
            org.opencontainers.image.source=${{ github.server_url }}/${{ github.repository }}
            org.opencontainers.image.version=$VERSION
            org.opencontainers.image.created=$BUILD_DATE
            org.opencontainers.image.revision=$GIT_COMMIT
            org.opencontainers.image.licenses=MIT
            org.opencontainers.image.vendor=kjanat

      # Sign the images with cosign (optional)
      - name: Sign the images with Cosign
        env:
          COSIGN_PASSWORD: ${{ secrets.COSIGN_PASSWORD }}
          COSIGN_PRIVATE_KEY: ${{ secrets.COSIGN_PRIVATE_KEY }}
        run: |
          cosign sign --key env://COSIGN_PRIVATE_KEY --yes ghcr.io/kjanat/chatlogger-api-${{ matrix.packages }}:latest
          cosign sign --key env://COSIGN_PRIVATE_KEY --yes ghcr.io/kjanat/chatlogger-api-${{ matrix.packages }}:$VERSION
          cosign sign --key env://COSIGN_PRIVATE_KEY --yes ghcr.io/kjanat/chatlogger-api-${{ matrix.packages }}:v$MAJOR
          cosign sign --key env://COSIGN_PRIVATE_KEY --yes ghcr.io/kjanat/chatlogger-api-${{ matrix.packages }}:v$MAJOR.$MINOR

      - name: Create dist directory
        if: github.ref_type == 'tag' || github.event_name == 'workflow_dispatch'
        run: mkdir -p dist

      # Build binaries for other platforms (similar to GoReleaser functionality)
      - name: Build Go binary ${{ matrix.goos }}-${{ matrix.goarch }}
        id: build_binary
        if: github.ref_type == 'tag' || github.event_name == 'workflow_dispatch'
        run: |
          GOOS=${{ matrix.goos }} GOARCH=${{ matrix.goarch }} \
          go build \
          -ldflags="-s -w -X github.com/kjanat/chatlogger-api-go/internal/version.Version=$VERSION_NO_V -X github.com/kjanat/chatlogger-api-go/internal/version.BuildTime=$BUILD_DATE -X github.com/kjanat/chatlogger-api-go/internal/version.GitCommit=$GIT_COMMIT" \
          -o dist/chatlogger-api-go-${{ matrix.packages }}-$VERSION-${{ matrix.goos }}-${{ matrix.goarch }} \
          ./cmd/${{ matrix.packages }}
          
      - name: Create ZIP archives and sign binaries
        if: github.ref_type == 'tag' || github.event_name == 'workflow_dispatch'
          # Create ZIP archives
        run: |
          cd dist
          for file in *; do
            cosign verify --key env://COSIGN_PUBLIC_KEY --signature "${file}.sig" "$file" || exit 1
            # Check if the file is a binary and create a ZIP archive
            if [ -f "$file" ]; then
              zip "${file}.zip" "$file" ../LICENSE ../README.md ../migrations/*
            fi
          done

      - name: Upload binaries as artifacts
        if: github.ref_type == 'tag' || github.event_name == 'workflow_dispatch'
        uses: actions/upload-artifact@v4
        with:
          name: chatlogger-api-binaries
          path: dist/*.zip
          retention-days: 1

      # Create GitHub release with binaries (optional)
      - name: Create GitHub Release
        if: github.ref_type == 'tag' || github.event_name == 'workflow_dispatch'
        uses: softprops/action-gh-release@v2
        with:
          files: dist/*.zip
          draft: false
          prerelease: false
          generate_release_notes: true
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
